//------------------------------------------------
//--- 010 Editor v15.0.1 Binary Template
//
//      File: TIM2/TM2 PS2 Graphics file
//   Authors: Bart≈Çomiej Duda (Ikskoks)
//   Version: 1.5
//   Purpose: File Formats Reverse Engineering
//  Category: Image/Texture
// File Mask: *.tim2 / *.tm2
//  ID Bytes: 54 49 4D 32 (TIM2)
//   History: v1.0  02.05.2025  Initial version
//            v1.1  23.12.2025  Minor fixes
//            v1.2  31.12.2025  Add new findings
//            v1.3  02.01.2026  Add new findings
//            v1.4  03.01.2026  Add support for user data
//            v1.5  04.01.2026  Add support for mipmaps
//------------------------------------------------

LittleEndian();

typedef enum <int> {
    TIM2_RGB16 = 1,
    TIM2_RGB24 = 2,
    TIM2_RGB32 = 3,
    TIM2_IDTEX4 = 4,
    TIM2_IDTEX8 = 5
} IMAGE_TYPE;

typedef enum <int> {
    PAL_NONE = 0,
    PAL_RGB16_CSM1 = 1,
    PAL_RGB32_CSM1 = 3,
    PAL_RGB16_CSM2 = 129,
    PAL_RGB32_CSM2 = 131,
} PALETTE_TYPE;


typedef enum <int> {
    SCE_GS_PSMCT32 = 0,
    SCE_GS_PSMT8 = 19,
    SCE_GS_PSMT4 = 20,
    SCE_GS_PSMT8H = 27,
    SCE_GS_PSMT4HL = 36,
    SCE_GS_PSMT4HH = 44,
    NOT_SWIZZLED = 100
} SWIZZLE_MODE;

typedef enum <int> {
    IDX_NONE = 0,
    IDX_SCE_GS_PSMT8H = 27,
    IDX_SCE_GS_PSMT4HL = 36,
    IDX_SCE_GS_PSMT4HH = 44,
} TEXEL_MODE;

struct FILE {
    struct HEADER {
        char signature[4];  // TIM2
        uint8 version;  // always 4?
        uint8 allignment;
        uint16 number_of_images;
        uint8 nulls[8];
        
        if (allignment > 0) {
            uint8 padding[112];
        }
        
    } header <bgcolor=cLtGreen>;
    
    local int i <hidden=true>';
    for( i = 0; i < header.number_of_images; i++ ) {
    
        struct IMAGE_HEADER {
            uint32 total_image_size;
            uint32 palette_size;
            uint32 image_data_size;
            uint16 image_header_size;
            uint16 number_of_colors_in_palette;
            uint8 picture_format;  // always 0
            uint8 number_of_mipmaps;  // 1 for only main image, >1 for main+mipmaps
            uint8 palette_type <hidden=true>;
            local PALETTE_TYPE palette_type_str = palette_type;
            uint8 image_type <hidden=true>;
            local IMAGE_TYPE image_type_str = image_type;
            uint16 image_width;
            uint16 image_height;
            uint8 GsTEX0[8];
            uint8 GsTEX1[8];
            uint32 GsRegs;
            uint32 GsTexClut;
            
            if ( (image_header_size - 48) > 0) {
                
            if (number_of_mipmaps > 1) {
                struct MIPMAPS_HEADER {
                    uint64 gsMiptbp1;
                    uint64 gsMiptbp2;
                    for( i = 0; i < number_of_mipmaps; i++ ) {
                        uint32 mipmap_image_size;
                    }
                    local uint32 current_offset <hidden=true> = FTell();
                    if (header.allignment == 0) {
                        local uint32 mipmaps_header_align_offset <hidden=true> = (current_offset + 16 - 1) & ~(16 - 1);
                        local uint32 mipmaps_header_align_size <hidden=true> = mipmaps_header_align_offset - current_offset;
                    } else {
                       local uint32 mipmaps_header_align_offset <hidden=true> = (current_offset + 128 - 1) & ~(128 - 1);
                       local uint32 mipmaps_header_align_size <hidden=true> = mipmaps_header_align_offset - current_offset;
                    }
                    if (mipmaps_header_align_size > 0) {
                        uint8 mipmaps_padding[mipmaps_header_align_size];
                    }
                } mipmaps_header <bgcolor=cYellow>;
            }


                struct EXT_HEADER {    
                    char ext_signature[4];  // "eXt\x00"
                    uint32 user_space_size;
                    uint32 user_data_size;
                    uint32 reserved;
                } ext_header <bgcolor=cRed>;
                
                struct SWIZ_HEADER {
                    char swiz_signature[4];  // "swiz" or nulls
                    uint16 width;
                    uint16 height;
                    uint8 swizzle_mode <hidden=true>;  // e.g. 0 -> SCE_GS_PSMCT32
                    local SWIZZLE_MODE swizzle_mode_str = swizzle_mode;
                    uint8 texel_mode <hidden=true>;  // e.g. 27 - SCE_GS_PSMT8H
                    local TEXEL_MODE texel_mode_str = texel_mode;
                } swiz_header <bgcolor=cBlue>;
                
                local uint32 total_user_data_size = image_header_size - 48;
                local uint32 user_data_padding_size = total_user_data_size - sizeof(ext_header) - sizeof(swiz_header);
                if (number_of_mipmaps > 1) {
                    user_data_padding_size -=  sizeof(mipmaps_header);
                }
                if (user_data_padding_size > 0) {
                    uint8 user_data_padding[user_data_padding_size];
                }
            }
                
        } image_header <bgcolor=cLtBlue>;
        
        uint8 image_data[image_header.image_data_size] <bgcolor=cLtRed>;
        if (image_header.palette_size > 0)
            uint8 palette_data[image_header.palette_size] <bgcolor=cLtYellow>;
    }

} file;
